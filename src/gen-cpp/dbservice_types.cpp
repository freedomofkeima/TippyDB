/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "dbservice_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dbservice {


Data::~Data() throw() {
}


void Data::__set_key(const std::string& val) {
  this->key = val;
}

void Data::__set_value(const std::string& val) {
  this->value = val;
}

void Data::__set_ts(const int64_t val) {
  this->ts = val;
}

const char* Data::ascii_fingerprint = "A0ED90CE9B69D7A0FCE24E26CAECD2AF";
const uint8_t Data::binary_fingerprint[16] = {0xA0,0xED,0x90,0xCE,0x9B,0x69,0xD7,0xA0,0xFC,0xE2,0x4E,0x26,0xCA,0xEC,0xD2,0xAF};

uint32_t Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Data");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Data &a, Data &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

Data::Data(const Data& other0) {
  key = other0.key;
  value = other0.value;
  ts = other0.ts;
  __isset = other0.__isset;
}
Data& Data::operator=(const Data& other1) {
  key = other1.key;
  value = other1.value;
  ts = other1.ts;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Data& obj) {
  using apache::thrift::to_string;
  out << "Data(";
  out << "key=" << to_string(obj.key);
  out << ", " << "value=" << to_string(obj.value);
  out << ", " << "ts=" << to_string(obj.ts);
  out << ")";
  return out;
}


ShardContent::~ShardContent() throw() {
}


void ShardContent::__set_data(const Shard& val) {
  this->data = val;
}

const char* ShardContent::ascii_fingerprint = "CADF07CD5CD3A18B4DEF7E3A4388D017";
const uint8_t ShardContent::binary_fingerprint[16] = {0xCA,0xDF,0x07,0xCD,0x5C,0xD3,0xA1,0x8B,0x4D,0xEF,0x7E,0x3A,0x43,0x88,0xD0,0x17};

uint32_t ShardContent::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->data.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->data[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShardContent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ShardContent");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<Data> ::const_iterator _iter7;
    for (_iter7 = this->data.begin(); _iter7 != this->data.end(); ++_iter7)
    {
      xfer += (*_iter7).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ShardContent &a, ShardContent &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

ShardContent::ShardContent(const ShardContent& other8) {
  data = other8.data;
  __isset = other8.__isset;
}
ShardContent& ShardContent::operator=(const ShardContent& other9) {
  data = other9.data;
  __isset = other9.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ShardContent& obj) {
  using apache::thrift::to_string;
  out << "ShardContent(";
  out << "data=" << to_string(obj.data);
  out << ")";
  return out;
}


GetRecover::~GetRecover() throw() {
}


void GetRecover::__set_term(const int32_t val) {
  this->term = val;
}

void GetRecover::__set_commit_idx(const int32_t val) {
  this->commit_idx = val;
}

void GetRecover::__set_entry(const std::string& val) {
  this->entry = val;
}

void GetRecover::__set_isLeader(const bool val) {
  this->isLeader = val;
}

const char* GetRecover::ascii_fingerprint = "255A92C076C015DBAC5DBD5B682082BE";
const uint8_t GetRecover::binary_fingerprint[16] = {0x25,0x5A,0x92,0xC0,0x76,0xC0,0x15,0xDB,0xAC,0x5D,0xBD,0x5B,0x68,0x20,0x82,0xBE};

uint32_t GetRecover::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->commit_idx);
          this->__isset.commit_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entry);
          this->__isset.entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isLeader);
          this->__isset.isLeader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetRecover::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("GetRecover");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("commit_idx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->commit_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->entry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isLeader", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->isLeader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(GetRecover &a, GetRecover &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.commit_idx, b.commit_idx);
  swap(a.entry, b.entry);
  swap(a.isLeader, b.isLeader);
  swap(a.__isset, b.__isset);
}

GetRecover::GetRecover(const GetRecover& other10) {
  term = other10.term;
  commit_idx = other10.commit_idx;
  entry = other10.entry;
  isLeader = other10.isLeader;
  __isset = other10.__isset;
}
GetRecover& GetRecover::operator=(const GetRecover& other11) {
  term = other11.term;
  commit_idx = other11.commit_idx;
  entry = other11.entry;
  isLeader = other11.isLeader;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const GetRecover& obj) {
  using apache::thrift::to_string;
  out << "GetRecover(";
  out << "term=" << to_string(obj.term);
  out << ", " << "commit_idx=" << to_string(obj.commit_idx);
  out << ", " << "entry=" << to_string(obj.entry);
  out << ", " << "isLeader=" << to_string(obj.isLeader);
  out << ")";
  return out;
}


AppendRequest::~AppendRequest() throw() {
}


void AppendRequest::__set_term(const int32_t val) {
  this->term = val;
}

void AppendRequest::__set_commit_idx(const int32_t val) {
  this->commit_idx = val;
}

void AppendRequest::__set_entry(const std::string& val) {
  this->entry = val;
}

const char* AppendRequest::ascii_fingerprint = "4086F12A5C2D615560236565C542F3C3";
const uint8_t AppendRequest::binary_fingerprint[16] = {0x40,0x86,0xF1,0x2A,0x5C,0x2D,0x61,0x55,0x60,0x23,0x65,0x65,0xC5,0x42,0xF3,0xC3};

uint32_t AppendRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->commit_idx);
          this->__isset.commit_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->entry);
          this->__isset.entry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppendRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AppendRequest");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("commit_idx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->commit_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entry", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->entry);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AppendRequest &a, AppendRequest &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.commit_idx, b.commit_idx);
  swap(a.entry, b.entry);
  swap(a.__isset, b.__isset);
}

AppendRequest::AppendRequest(const AppendRequest& other12) {
  term = other12.term;
  commit_idx = other12.commit_idx;
  entry = other12.entry;
  __isset = other12.__isset;
}
AppendRequest& AppendRequest::operator=(const AppendRequest& other13) {
  term = other13.term;
  commit_idx = other13.commit_idx;
  entry = other13.entry;
  __isset = other13.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const AppendRequest& obj) {
  using apache::thrift::to_string;
  out << "AppendRequest(";
  out << "term=" << to_string(obj.term);
  out << ", " << "commit_idx=" << to_string(obj.commit_idx);
  out << ", " << "entry=" << to_string(obj.entry);
  out << ")";
  return out;
}


AppendResponse::~AppendResponse() throw() {
}


void AppendResponse::__set_term(const int32_t val) {
  this->term = val;
}

void AppendResponse::__set_succeeds(const bool val) {
  this->succeeds = val;
}

const char* AppendResponse::ascii_fingerprint = "4DC0C1A1F380340B40244ADC7FB0BA60";
const uint8_t AppendResponse::binary_fingerprint[16] = {0x4D,0xC0,0xC1,0xA1,0xF3,0x80,0x34,0x0B,0x40,0x24,0x4A,0xDC,0x7F,0xB0,0xBA,0x60};

uint32_t AppendResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->succeeds);
          this->__isset.succeeds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppendResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AppendResponse");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("succeeds", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->succeeds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AppendResponse &a, AppendResponse &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.succeeds, b.succeeds);
  swap(a.__isset, b.__isset);
}

AppendResponse::AppendResponse(const AppendResponse& other14) {
  term = other14.term;
  succeeds = other14.succeeds;
  __isset = other14.__isset;
}
AppendResponse& AppendResponse::operator=(const AppendResponse& other15) {
  term = other15.term;
  succeeds = other15.succeeds;
  __isset = other15.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const AppendResponse& obj) {
  using apache::thrift::to_string;
  out << "AppendResponse(";
  out << "term=" << to_string(obj.term);
  out << ", " << "succeeds=" << to_string(obj.succeeds);
  out << ")";
  return out;
}


VoteRequest::~VoteRequest() throw() {
}


void VoteRequest::__set_term(const int32_t val) {
  this->term = val;
}

void VoteRequest::__set_last_commit_idx(const int32_t val) {
  this->last_commit_idx = val;
}

void VoteRequest::__set_peer_id(const int32_t val) {
  this->peer_id = val;
}

const char* VoteRequest::ascii_fingerprint = "6435B39C87AB0E30F30BEDEFD7328C0D";
const uint8_t VoteRequest::binary_fingerprint[16] = {0x64,0x35,0xB3,0x9C,0x87,0xAB,0x0E,0x30,0xF3,0x0B,0xED,0xEF,0xD7,0x32,0x8C,0x0D};

uint32_t VoteRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->last_commit_idx);
          this->__isset.last_commit_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->peer_id);
          this->__isset.peer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VoteRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("VoteRequest");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_commit_idx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->last_commit_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peer_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->peer_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(VoteRequest &a, VoteRequest &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.last_commit_idx, b.last_commit_idx);
  swap(a.peer_id, b.peer_id);
  swap(a.__isset, b.__isset);
}

VoteRequest::VoteRequest(const VoteRequest& other16) {
  term = other16.term;
  last_commit_idx = other16.last_commit_idx;
  peer_id = other16.peer_id;
  __isset = other16.__isset;
}
VoteRequest& VoteRequest::operator=(const VoteRequest& other17) {
  term = other17.term;
  last_commit_idx = other17.last_commit_idx;
  peer_id = other17.peer_id;
  __isset = other17.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const VoteRequest& obj) {
  using apache::thrift::to_string;
  out << "VoteRequest(";
  out << "term=" << to_string(obj.term);
  out << ", " << "last_commit_idx=" << to_string(obj.last_commit_idx);
  out << ", " << "peer_id=" << to_string(obj.peer_id);
  out << ")";
  return out;
}


VoteResponse::~VoteResponse() throw() {
}


void VoteResponse::__set_term(const int32_t val) {
  this->term = val;
}

void VoteResponse::__set_granted(const bool val) {
  this->granted = val;
}

const char* VoteResponse::ascii_fingerprint = "4DC0C1A1F380340B40244ADC7FB0BA60";
const uint8_t VoteResponse::binary_fingerprint[16] = {0x4D,0xC0,0xC1,0xA1,0xF3,0x80,0x34,0x0B,0x40,0x24,0x4A,0xDC,0x7F,0xB0,0xBA,0x60};

uint32_t VoteResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->granted);
          this->__isset.granted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VoteResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("VoteResponse");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("granted", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->granted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(VoteResponse &a, VoteResponse &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.granted, b.granted);
  swap(a.__isset, b.__isset);
}

VoteResponse::VoteResponse(const VoteResponse& other18) {
  term = other18.term;
  granted = other18.granted;
  __isset = other18.__isset;
}
VoteResponse& VoteResponse::operator=(const VoteResponse& other19) {
  term = other19.term;
  granted = other19.granted;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const VoteResponse& obj) {
  using apache::thrift::to_string;
  out << "VoteResponse(";
  out << "term=" << to_string(obj.term);
  out << ", " << "granted=" << to_string(obj.granted);
  out << ")";
  return out;
}

} // namespace
